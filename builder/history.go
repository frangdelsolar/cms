package builder

import (
	"encoding/json"
	"fmt"
	"time"

	"gorm.io/gorm"
)

type CRUDAction string

const (
	CreateCRUDAction CRUDAction = "created"
	UpdateCRUDAction CRUDAction = "updated"
	DeleteCRUDAction CRUDAction = "deleted"
)

type HistoryEntry struct {
	gorm.Model
	Timestamp    string     `gorm:"type:timestamp" json:"timestamp"`
	User         *User      `json:"user"`
	UserId       string     `gorm:"foreignKey:UserId" json:"userId"`
	Action       CRUDAction `json:"action"`
	ResourceName string     `json:"resourceName"`
	ResourceId   string     `json:"resourceId"`
	Detail       string     `json:"detail"`
}

// NewLogHistoryEntry takes an action of type CRUDAction, a user ID, and an object, and returns a pointer to a HistoryEntry and an error.
// The HistoryEntry is generated by marshaling the object to JSON, and extracting the ID from it if it exists.
// The object is expected to be a struct with a JSON tag for the ID field named "ID".
// The function returns an error if the object cannot be marshaled or unmarshaled to JSON.
// The function uses the GetStructName function to get the name of the struct from the object passed in.
func NewLogHistoryEntry(action CRUDAction, userId string, object interface{}) (*HistoryEntry, error) {
	name := GetStructName(object)
	jsonData, err := json.Marshal(object)
	if err != nil {
		return nil, err
	}

	var objJson map[string]interface{}
	err = json.Unmarshal(jsonData, &objJson)
	if err != nil {
		return nil, err
	}

	resourceId := ""
	if objJson["ID"] != nil {
		resourceId = fmt.Sprintf("%v", objJson["ID"])
	}

	// TODO: maybe worth trying to store just the differences, specially for updates
	detail := string(jsonData)

	historyEntry := &HistoryEntry{
		Timestamp:    time.Now().Format(time.RFC3339),
		Action:       action,
		UserId:       userId,
		ResourceId:   resourceId,
		ResourceName: name,
		Detail:       detail,
	}

	return historyEntry, nil
}

// GetHistoryEntryForInstanceFromDB returns a HistoryEntry if a record exists in the history table with the given parameters.
//
// The function takes a database, a user ID, a resource, a resource ID, a resource name, and a CRUD action as parameters,
// and constructs a query to retrieve a HistoryEntry from the database.
// It then executes the query and returns the HistoryEntry and any error that may have occurred.
func GetHistoryEntryForInstanceFromDB(db *Database, userId string, resource interface{}, resourceId string, resourceName string, crudAction CRUDAction) (HistoryEntry, error) {
	expectedDetail, err := json.Marshal(resource)
	if err != nil {
		return HistoryEntry{}, err
	}

	var historyEntry HistoryEntry

	q := "user_id = '" + userId + "'"
	q += " AND "
	q += "action = '" + string(crudAction) + "'"
	q += " AND "
	q += "resource_name = '" + resourceName + "'"
	q += " AND "
	q += "detail = '" + string(expectedDetail) + "'"
	q += " AND "
	q += "resource_id = '" + resourceId + "'"

	err = db.DB.First(&historyEntry).Where(q).Error
	return historyEntry, err
}
